# -*- coding: utf-8 -*-
"""
Created on Sat Dec 06 15:27:38 2014

@author: Israel
"""


# TODO: Add Checks
# TODO: Add summary  
# TODO: handle if first window data is missing 

import pandas as pd
import numpy as np


class strategy(object):

    ''' Strategy is a class to represent investment strategies. 
    
    This class contains returns generated by the strategy and associated metadata.
    
    A strategy is defined by:
        - the investment universe on which the strategy is defined
        - the signal used to select specific investments
        - the weighting scheme used to allocate funds across the selected investments
        - these 3 components are used to generate the value of that
    
    Public Attributes:
        Data attributes:
        - signal: dataframe containing the signal used to select stocks (example: rolling returns)
        - selection: dataframe of zeros and ones to identify the selected investments
        - weights: dataframe containing the weights allocated to each selected investment
        - strategy: dataframe with the value of each investment and the total value ('value')
        - parameters: dictionary containing metadata
        
        Parameters Dictionary:
        - universe: the name of universe object on which the strategy is defined
        - signalName: the signal used to generate the strategy 
        - rule: the cutoff point for selecting investments
        - window: size of window between rebalancing 
        - startDate: starting date for strategy
        - endDate: ending date for strategy
    '''
    
    
    
    def __init__(self,universe,configPath):
        ''' Method to intialize a strategy object
        
            1) Reads in parameters from configPath      
            2) Calculates signal and sets as attribute
            3) Selects investments based on signal and sets as attribute
            4) Calculates weights ands sets as attribute
            5) Calculates strategy values and sets as attribute
            
        Args:
            configPath (str): location of config file
            universe (universe): universe on which the strategy is defined 
          
        '''
        
        # pull parameters from config file 
        self.parameters = self.__setParameters(configPath)
        self.parameters['universe']=str(universe)
        
        # set private attributes used for calculations
        self._signalType = self.parameters['signalType']
        self._rule = int(self.parameters['rule'])
        self._window = int(self.parameters['window'])
        self._startDate = self.parameters['startDate']
        self._endDate = self.parameters['endDate']
        self._tickers = universe.returns.columns.values
        self._returns = universe.returns.copy()
        self._dates = self._returns[self._startDate : self._endDate].index
        self._rebalanceDates = self._dates[::self._window]
        
        # set attributes
        self.__setSignal()
        self.__setSelection()
        self.__setWeights()
        self.__setStrategy()
        
        
        # TODO: Add checks for if file exists     
    def __setParameters(self, configPath):
        """ Method to read config file
        
        Note:
            configPath is assumed to be a .txt file with (at least) the following fields:
              - name : a name/description for the strategy
              - signalType: signal type used for selecting investments (ex. 'rollingReturns')
              - rule: the cutoff point for selecting investment (positive/negative int-->pick top/bottom S investments)
              - window: time-span between rebalancing
              - startDate: strategy starting date
              - endDate: strategy ending date
        
        Args:
            configPath (str): location of config file
          
        Returns:
            A dict with {key = parameter name: value = parameter value} 
            
        """
        
        # Load Data
        parameters = pd.read_table(configPath , sep = '=', index_col = 0, header = None)
        parameters.columns = ['values']        
        
        # Strip spaces
        parameters = parameters.astype('string')        
        parameters.index = parameters.index.map(str.strip)        
        parameters = parameters['values'].map(str.strip)
        
        return parameters.to_dict()
        
        
        
        
    def __setSignal(self):
        """ Method to set self.signal
        
        """
        
        if self._signalType=='rollingRet':
            self.signal = strategy.calcRollRet(self._returns,self._window).ix[self._rebalanceDates][self._tickers]
      


      
    def __setSelection(self):
        """ Method to set self.selection
        
            Note: includes checks to make sure there are enough non-Nan observations to make full selection
        
        """
        
        # Case 1: cutoff rule is positive
        if self._rule>0:
            mask = (self.signal.rank(axis=1)<=self._rule)*(self.signal.notnull())
        # Case 2: cutoff rule is negative    
        if self._rule>0:
            mask = ((-1*self.signal).rank(axis=1)<=self._rule)*(self.signal.notnull())
        
        # Check to make sure there are enough non-Nan values
        if mask.sum(axis=1).sum() < np.abs(self._rule)*mask.shape[0]:
            print "Israel will add an error here"
            
        self.selection = mask
            
         
         
         
            
    def __setWeights(self):
        """ Method to set self.weights
        
            Note: normalizes so that the weights for each day sum to 1
        
        """
        
        rawWeights = pd.DataFrame(1,index=self._rebalanceDates,columns=self._tickers)*self.selection
        sumWeights = rawWeights.sum(axis=1).replace(0,1)
        normWeights = rawWeights/sumWeights
        self.weights = normWeights
        
        
        
        
    def __setStrategy(self):
        """ Method to set self.strategy
        
            Calculates the value of each investment and the overall value of the strategy,
            using the weights based on the input parameters.
        
            Returns:
                A dataframe with the value of each investment and and the overall strategy ('value') 
        """
        
        # set parameters and lists to prepare for merge        
        weights = self.weights.copy()
        weightTickers = [str(x)+'_w' for x in weights.columns]
        weights['rebalance'] = 1
         
        # merge the returns dataframe with the weights dataframe and forward fill weight data
        merged = pd.merge(self._returns,weights,how='left',left_index=True,right_index=True,suffixes=['_r','_w'])
        merged['block'] = None
        merged['block'][merged.rebalance==1] = np.arange((merged.rebalance==1).sum())
        merged['block'] = merged['block'].fillna(method='ffill')
        merged = merged[merged['block']!=0]
        merged = merged.drop('rebalance',axis=1)
        merged[weightTickers] = merged[weightTickers].fillna(method='ffill')
         
        # before grouping by block (time span between rebalancing), set a global to 0.
        # this global is used to carry infomation (value on previous day) across the groups/blocks.
        global portValueGlobal
        portValueGlobal=0
        rebalanced = merged.groupby('block').apply(strategy.calcRebalancing,tickers=self._tickers)
         
        # keep the investment values and total value columns
        columnsToKeep = self._tickers.tolist()[:]
        columnsToKeep.append('value')
        self.strategy = rebalanced[columnsToKeep]
         
         




    @ staticmethod        
    # will be moved to util
    def calcRollRet(returns,spansize):
        ''' Returns spansize-window rolling returns.
        
        Note:
            Assumes returns are in decimal form (ex. 0.02 is a 2% return)
            If any of the data points within the window are NaN, then value for entire window is NaN
        
        Args:
            returns (dataframe): dataframe containing returns data
            spansize (int): size of rolling-window
        
        Returns:
            A dataframe with spansize-window rolling returns
            
        ''' 
        
        rollRet = (pd.rolling_apply(1+returns,window=int(spansize),func=np.prod) - 1)
        filterMissing = pd.rolling_count(returns,int(spansize))==int(spansize)
        rollRetClean = rollRet * (1*filterMissing)
        return rollRetClean





    @ staticmethod
    # will be moved to util
    def calcRebalancing(df,tickers):
        global portValueGlobal
        
        for t in tickers: 
            df[t] = ((1+df[t+'_r']).cumprod())*(df[t+'_w'])*portValueGlobal
        df['value'] = df[tickers].sum(axis=1)
        
        # chunk of code below where the global tracking is if/elsed is
        # due to a bug in pandas groupby. See warning at url below.
        # http://pandas.pydata.org/pandas-docs/dev/groupby.html
        
        if portValueGlobal==0:
            portValueGlobal=1
        else:
            portValueGlobal = df['value'].iloc[-1]

        return df



        